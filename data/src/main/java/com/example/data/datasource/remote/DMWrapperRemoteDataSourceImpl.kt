
package com.example.data.datasource.remote

import com.example.core_common.constants.FirestoreConstants
import com.example.core_common.constants.FirestoreConstants.Users.DMWrappers
import com.example.core_common.result.CustomResult
import com.example.core_common.result.resultTry
import com.example.data.model.remote.DMWrapperDTO
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.Query
import com.google.firebase.firestore.snapshots
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class DMWrapperRemoteDataSourceImpl @Inject constructor(
    private val auth: FirebaseAuth,
    private val firestore: FirebaseFirestore
) : DMWrapperRemoteDataSource {

    companion object {
        // If you decide to keep dm_wrappers as a subcollection under users:
        // private const val USER_SPECIFIC_DM_WRAPPER_SUBCOLLECTION = "dm_wrappers"
    }

    // Existing observeDmWrappers methods - these might need adjustment
    // if we move to a single global dm_wrappers collection and query by participantId.
    // For now, let's assume they remain as is, implying dm_wrappers are per-user.
    // This means createDMWrapper will need to write to two locations.

    override fun observeDmWrappers(): Flow<List<DMWrapperDTO>> {
        val uid = auth.currentUser?.uid
            ?: return kotlinx.coroutines.flow.flow { throw Exception("User not logged in.") }

        // This observes the user-specific copy of DM wrappers
        return firestore.collection(FirestoreConstants.Collections.USERS).document(uid)
            .collection(DMWrappers.COLLECTION_NAME) // Assuming subcollection name is consistent
            .snapshots()
            .map { snapshot -> snapshot.documents.mapNotNull { it.toObject(DMWrapperDTO::class.java) } }
    }

    override fun observeDmWrappers(userId: String): Flow<List<DMWrapperDTO>> {
        // This observes a specific user's copy of DM wrappers
        return firestore.collection(FirestoreConstants.Collections.USERS).document(userId)
            .collection(DMWrappers.COLLECTION_NAME) // Assuming subcollection name is consistent
            .snapshots()
            .map { snapshot -> snapshot.documents.mapNotNull { it.toObject(DMWrapperDTO::class.java) } }
    }

    /**
     * Creates a DMWrapper document in a global collection 'dm_wrappers'.
     * It's assumed that DMWrapperDTO contains all necessary fields including 'participants'.
     * The ID for the DMWrapper document will be auto-generated by Firestore.
     */
    override suspend fun createDMWrapper(userId : String, dmWrapperDto: DMWrapperDTO): CustomResult<String, Exception> {
        return try {
            // Ensure participants are sorted for consistent querying if needed elsewhere,
            // though for creation, the DTO should already have this.
            // val sortedParticipants = dmWrapperDto.participants.sorted()
            // val dtoWithSortedParticipants = dmWrapperDto.copy(participants = sortedParticipants)


            // Additionally, if you maintain per-user copies as implied by observeDmWrappers:
            // This part needs careful consideration for atomicity (e.g., using batched writes or Cloud Functions)
            // For simplicity here, we'll just write them. If one fails, there could be inconsistency.
            firestore.collection(FirestoreConstants.Collections.USERS).document(userId)
                .collection(DMWrappers.COLLECTION_NAME) // Using the same name for subcollection
                .document(dmWrapperDto.dmChannelId) // Use the same ID as the global one
                .set(dmWrapperDto) // Set the same DTO
                .await()
            CustomResult.Success(dmWrapperDto.dmChannelId)
        } catch (e: Exception) {
            CustomResult.Failure(e)
        }
    }

    /**
     * Finds a DMWrapper in the global 'dm_wrappers' collection by exact participants.
     * Assumes DMWrapperDTO has a 'participants' field which is a list of user IDs.
     * The participantIds list provided to this function MUST be sorted to ensure query consistency.
     */
    override suspend fun findDMWrapperByExactParticipants(userId: String, otherUserId: String): CustomResult<DMWrapperDTO, Exception> {
        // Ensure the input list is sorted for the query, as Firestore array equality depends on order and elements.

        return resultTry {
            val document = firestore.collection(FirestoreConstants.Collections.USERS).document(userId)
                .collection(DMWrappers.COLLECTION_NAME)
                .document(otherUserId)
                .get()
                .await()

            document.toObject(DMWrapperDTO::class.java)
                    ?: throw Exception("Failed to parse DMWrapperDTO from Firestore document: ${document.id}")
        }
    }
}

